[{"content":"","date":"2025-10-24","externalUrl":null,"permalink":"/tags/linux/","section":"Tags","summary":"","title":"Linux","type":"tags"},{"content":" 安装命令 # # 安装zsh sudo apt install zsh # 下载oh my zsh git clone git@github.com:ohmyzsh/ohmyzsh.git ~/.oh-my-zsh git clone https://github.com/ohmyzsh/ohmyzsh.git ~/.oh-my-zsh # 复制oh my zsh配置 cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc # 设置默认终端为zsh chsh -s /bin/zsh # 打开zsh zsh # 下载补全插件 git clone git@github.com:zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions # 编辑配置文件，修改 plugins=(git zsh-autosuggestions) nano ~/.zshrc # 重启zsh source .zshrc 参考 oh-my-zsh安装\n","date":"2025-10-24","externalUrl":null,"permalink":"/posts/zsh/","section":"文章","summary":"","title":"oh-my-zsh安装","type":"posts"},{"content":"","date":"2025-10-24","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" ","date":"2025-10-24","externalUrl":null,"permalink":"/","section":"欢迎来到 Blowfish ！","summary":"","title":"欢迎来到 Blowfish ！","type":"page"},{"content":"","date":"2025-10-24","externalUrl":null,"permalink":"/posts/","section":"文章","summary":"","title":"文章","type":"posts"},{"content":"","date":"2025-10-20","externalUrl":null,"permalink":"/tags/acm/","section":"Tags","summary":"","title":"ACM","type":"tags"},{"content":" 本文为SIT2025新生赛Python版本题解，仅供参考，如有疑问可群里艾特\u0026quot;木子木\u0026quot; 本文标题均可点击链接跳转题目\n比赛链接\nA 欢迎来到SIT算法竞赛社 # _ = input() print(sum(list(map(int, input().split())))) B 寻找平衡日 # n = int(input()) nums = list(map(int, input().split())) total = sum(nums) prefix = [sum(nums[:i]) for i in range(len(nums) + 1)] for i in range(1, n + 1): left_sum = prefix[i - 1] right_sum = total - prefix[i] if left_sum == right_sum: print(i) exit(0) print(-1) C 编程友谊赛 # from collections import defaultdict from math import comb count = defaultdict(int) for _ in range(int(input())): s = input().strip() freq = \u0026#39;\u0026#39;.join(sorted(f\u0026#34;{c}:{s.count(c)}\u0026#34; for c in set(s))) count[freq] += 1 print(sum(comb(v, 2) for v in count.values())) D 队伍分配问题 # n = int(input()) nums = list(map(int, input().split())) print(\u0026#34;true\u0026#34; if len(set(nums)) == n else \u0026#34;false\u0026#34;) E 能做到吗 # x, y, n, t, k = map(int, input().split()) a = list(map(int, input().split())) b = list(map(int, input().split())) dp = [0] * (y + 1) for i in range(n): for j in range(y, a[i] - 1, -1): dp[j] = max(dp[j], dp[j - a[i]] + b[i]) if x + dp[y] // t \u0026gt;= k: print(\u0026#34;YES\u0026#34;) else: print(\u0026#34;NO\u0026#34;) F 社长选举 # 暴力解法(TLE)\nn = int(input()) nums = list(map(int, input().split())) max_cnt, best_k = -1, 0 for k in range(n): count = 0 for i in range(n): if nums[i] \u0026lt;= (i + k) % n: count += 1 if count \u0026gt; max_cnt: max_cnt, best_k = count ,k print(best_k) J 你的故事你来写 # print(\u0026#34;你的故事你来写\u0026#34;) ","date":"2025-10-20","externalUrl":null,"permalink":"/posts/acm/sit/contest2025/","section":"文章","summary":"","title":"SIT算法竞赛社2025年新生赛","type":"posts"},{"content":" 为什么选用Python写算法题 # 毋庸置疑，Python是主流编程语言中语法最简洁的，再加上python内置函数丰富，熟练之后写算法题可以大幅减少代码量和用时。\n面向ICPC/CCPC的同学出于性能考虑往往会采用C++作为首选编程语言，但是在普通比赛或者面试中碰到的编程题并不会卡编程语言的时间，只要算法的时间复杂度达标即可通过，所以当习惯使用Python写算法题后可以提高效率，并且能够体会到Python的简洁之道。\n常用技巧 # Counter # c = Counter(list) for k, v in c.items(): print(k, v) for k in c.keys(): print(k, c[k]) for v in c.values(): print(v) for i in c.elements(): print(i) dict = defaultdict(list) #默认为空列表 dict = defaultdict(int) #默认为0 for k, v in dict: print(k, v) 推导式 # # 列表推导式 newnames = [name.upeer() for name in names if len(name) \u0026gt; 3] multiples = [i for i in range(30) if 3 % 3 == 0] # 字典推导式 newdict = {key:len(key) for key in listdemo} dic = {x:x**2 for x in (2, 4, 6)} # 集合推导式 newset = {i**2 for i in (1, 2, 3)} a = {x for x in \u0026#39;abracadabra\u0026#39; if x not in \u0026#39;abc\u0026#39;} 自定义排序 # data = [(\u0026#39;red\u0026#39;, 5), (\u0026#39;blue\u0026#39;, 1), (\u0026#39;yellow\u0026#39;, 8), (\u0026#39;black\u0026#39;, 0)] data.sort(key=lambda r: r[1]) # 自定义排序函数 def custom_sort_key(item): # 根据item的某种特性生成排序键 return item[\u0026#39;priority\u0026#39;] # 假设我们按照优先级排序 # 示例数据 items = [ {\u0026#39;name\u0026#39;: \u0026#39;A\u0026#39;, \u0026#39;priority\u0026#39;: 2}, {\u0026#39;name\u0026#39;: \u0026#39;B\u0026#39;, \u0026#39;priority\u0026#39;: 1}, {\u0026#39;name\u0026#39;: \u0026#39;C\u0026#39;, \u0026#39;priority\u0026#39;: 3}, ] # 使用sorted()进行排序 sorted_items = sorted(items, key=custom_sort_key) print(sorted_items) # 输出排序后的列表 # 使用list.sort()进行排序 items.sort(key=custom_sort_key) print(items) # 输出就地排序后的列表 记忆化函数 # from functools import cache # 在函数前使用@cache即可完成记忆化函数 二分查找函数 # import bisect my_list = [1, 3, 5, 5, 7, 9] # 使用 bisect_left 查找目标元素的插入位置 left_index = bisect.bisect_left(my_list, 5) print(\u0026#34;插入位置（最左边）:\u0026#34;, left_index) # 使用 bisect_right 查找目标元素的插入位置 right_index = bisect.bisect_right(my_list, 5) print(\u0026#34;插入位置（最右边）:\u0026#34;, right_index) 插入位置（最左边）: 2 插入位置（最右边）: 4 # 详细使用： bisect.bisect_left(a, x, lo=0, hi=len(a), *, key=None) 在列表a的[lo,hi)子集块中查找第一个大于等于x的下标 bisect.bisect_right(a, x, lo=0, hi=len(a), *, key=None) 在列表a的[lo,hi)子集块中查找第一个大于x的下标 # 自定义比较规则 my_list = [1, 3, 5, 7, 9] index = bisect.bisect_left(my_list, 5, key=lambda x: x * x) # 应用示例 成绩分组 def grade(score, breakpoints=[60, 70, 80, 90], grades=\u0026#39;FDCBA\u0026#39;): i = bisect(breakpoints, score) return grades[i] [grade(score) for score in [33, 99, 77, 70, 89, 90, 100]] [\u0026#39;F\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;A\u0026#39;] 通用模板 # 此模版面向ICPC/CCPC竞赛，如果对于python代码有性能需求可以考虑使用模板中封装的IO模块\nimport sys, os, math from math import gcd, sqrt from bisect import bisect_left, bisect_right from io import BytesIO, IOBase from collections import Counter, defaultdict, deque from functools import lru_cache, reduce, cmp_to_key from itertools import accumulate, combinations, permutations, product from heapq import nsmallest, nlargest, heapify, heappop, heappush BUFSIZE = 8192 def solve(): n = 1 def main(): tt = 1 tt = II() for _ in range(tt): solve() def qmi(a, b, p): res = 1 % p while b: if b \u0026amp; 1: res = (res * a) % p a = a * a % p b \u0026gt;\u0026gt;= 1 return res def comb(n, r): return factorial(n) // (factorial(r) * factorial(n - r)) if n \u0026gt;= r else 0 def I(): return input() def II(): return int(input()) def MII(): return map(int, input().split()) def LMII(): return list(map(int, input().split())) def YES(t = 1): print(\u0026#34;YES\u0026#34; if t else \u0026#34;NO\u0026#34;) def NO(t = 1): YES(t ^ 1) def Yes(t = 1): print(\u0026#34;Yes\u0026#34; if t else \u0026#34;No\u0026#34;) def No(t = 1): Yes(t ^ 1) def yes(t = 1): print(\u0026#34;yes\u0026#34; if t else \u0026#34;no\u0026#34;) def no(t = 1): yes(t ^ 1) class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = \u0026#34;x\u0026#34; in file.mode or \u0026#34;r\u0026#34; not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b\u0026#34;\\n\u0026#34;) + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(\u0026#34;ascii\u0026#34;)) self.read = lambda: self.buffer.read().decode(\u0026#34;ascii\u0026#34;) self.readline = lambda: self.buffer.readline().decode(\u0026#34;ascii\u0026#34;) sys.stdin = IOWrapper(sys.stdin) input = lambda: sys.stdin.readline().rstrip() if __name__ == \u0026#34;__main__\u0026#34;: main() ","date":"2025-10-17","externalUrl":null,"permalink":"/posts/acm/python/","section":"文章","summary":"","title":"Python算法题常用技巧","type":"posts"},{"content":"","date":"2025-10-17","externalUrl":null,"permalink":"/tags/%E9%9D%A2%E8%AF%95/","section":"Tags","summary":"","title":"面试","type":"tags"},{"content":" ACM输入输出模板 # 很多朋友在求职的笔试和面试中，因为对ACM模式的输入输出不熟悉，导致无法完成算法题。输入输出是写算法题的基础，大家可以根据自己的首选语言进行\u0026quot;背诵\u0026quot;。\n下面，针对常见的ACM输入与输出，给大家总结了模板写法，包括了C++、Python、Go、Java、JavaScript等主流编程语言。示例代码均为“A+B”问题，题目描述为输入A和B两个数，要求输出A+B。\n1.多组数据，每组第一行为n，之后输入n行两个整数 # 练习题：A+B问题I\n输入：第一行是一个整数N，表示后面会有N行a和b，通过空格隔开。\nC++ # #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int n, a, b; while (cin \u0026gt;\u0026gt; n) { while (n--) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; cout \u0026lt;\u0026lt; a + b \u0026lt;\u0026lt; endl; } } } Python # n = int(input()) for _ in range(n): a, b = map(int, input().split()) print(a + b) Go # package main import \u0026#34;fmt\u0026#34; func main(){ var n, a, b int for { _, err := fmt.Scanf(\u0026#34;%d\u0026#34;, \u0026amp;n) if err != nil { break } for n \u0026gt; 0 { _, err := fmt.Scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;a, \u0026amp;b) if err != nil { break } fmt.Println(a + b) n -- } } } Java # import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { int n = scanner.nextInt(); while (n -- \u0026gt; 0) { int a = scanner.nextInt(); int b = scanner.nextInt(); System.out.println(a + b); } } } } JavaScript # const readline = require(\u0026#39;readline\u0026#39;); const rl = readline.createInterface({ input: process.stdin, output: process.stdout }); let n, count = 0; rl.on(\u0026#39;line\u0026#39;, (input) =\u0026gt; { if (!n) { n = +line; } else { const [a, b] = line.split(\u0026#39; \u0026#39;).map(Number); console.log(a + b)… if (++ count \u0026gt;= n) rl.close(); } }) 1.多行输入，每行两个整数 # 练习题：A+B问题II\n输入：包含一系列的a和b对，通过空格隔开。一对a和b占一行。\nC++ # #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int a, b; while(cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b) cout \u0026lt;\u0026lt; a + b \u0026lt;\u0026lt; endl; } Python # while True: try: a, b = map(int, input().split()) print(a + b) except: break Go # package main import \u0026#34;fmt\u0026#34; func main(){ var a, b int for { _, err := fmt.Scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;a, \u0026amp;b) if err != nil { break } fmt.Println(a + b) } } Java # import java.util.Scanner; public class Main{ public static void main(String[] args){ Scanner in = new Scanner(System.in); while(in.hasNextInt()){ int a = in.nextInt(); int b = in.nextInt(); System.out.println( a + b ); } } } JavaScript # const readline = require(\u0026#39;readline\u0026#39;); const rl = readline.createInterface({ input: process.stdin, output: process.stdout }); rl.on(\u0026#39;line\u0026#39;, (input) =\u0026gt; { const [a, b] = input.split(\u0026#39; \u0026#39;).map(Number); console.log(a + b); }) ","date":"2025-10-13","externalUrl":null,"permalink":"/posts/acm/io/","section":"文章","summary":"","title":"ACM输入输出模板","type":"posts"},{"content":"","date":"13 October 2025","externalUrl":null,"permalink":"/en/tags/programing/","section":"Tags","summary":"","title":"Programing","type":"tags"},{"content":"","date":"2025-09-27","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"2025-09-27","externalUrl":null,"permalink":"/tags/git/","section":"Tags","summary":"","title":"Git","type":"tags"},{"content":"","date":"27 September 2025","externalUrl":null,"permalink":"/en/series/git-documents/","section":"Series","summary":"","title":"Git Documents","type":"series"},{"content":" 使用Windows如何配置SSH连接Github # 在往github上push项目的时候，如果走https的方式，每次都需要输入账号密码，非常麻烦。而采用ssh的方式，就不再需要输入，只需要在github自己账号下配置一个ssh key即可。\n一、检查本地主机是否已经存在ssh key # win + R打开运行 ，输入cmd打开命令行\n输入以下命令\ncd .ssh dir 如果存在id_rsa 和 id_rsa.pub文件，如果存在，说明已经有SSH Key。下图即表示存在。\n如果存在，则直接执行第三步。\n二、生成ssh key # 如果不存在，使用下列命令生成。\nssh-keygen -t rsa -C \u0026#34;xxx@xxx.com\u0026#34; // 将 \u0026#34;xxx@xxx.com\u0026#34; 替换为你自己GitHub的邮箱地址 一直回车即可。\n三、获取ssh key公钥内容（id_rsa.pub） # cd .ssh type id_rsa.pub // Windows命令行 cat id_rsa.pub // Linux命令行 如下图所示，复制这段内容\n四、Github账号上添加公钥 # 1、点击右上角的头像，进入settings设置，添加SSH Keys。\n2、将刚刚复制的内容添加上去\n五、验证是否设置成功 # ssh -T git@github.com 显示如下则表示设置成功\n设置成功后，即可不需要账号密码clone和push代码\n注意之后在clone仓库的时候要使用ssh的url，而不是https！\n","date":"2025-09-27","externalUrl":null,"permalink":"/posts/git/gitssh/","section":"文章","summary":"使用Windows如何配置SSH连接Github","title":"GitHub SSH配置","type":"posts"},{"content":"","date":"2025-09-27","externalUrl":null,"permalink":"/series/git%E6%95%99%E7%A8%8B/","section":"Series","summary":"","title":"Git教程","type":"series"},{"content":"","date":"2025-09-27","externalUrl":null,"permalink":"/authors/muzimu/","section":"Authors","summary":"","title":"Muzimu","type":"authors"},{"content":"","date":"2025-09-27","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"2025-09-27","externalUrl":null,"permalink":"/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","section":"Tags","summary":"","title":"环境配置","type":"tags"},{"content":" 基本介绍 # 在使用Git进行代码仓库管理的时候，我们不可避免需要提交Commit，即每次提交代码需要标注本次进行了哪些修改，方便让合作者快速阅览了解开发内容，提高合作效率。目前Angular规范是最广泛的Git Commit规范方法，本文参考下列文档，使用中文编写新手友好的实用教程。 Augular Github规范 参考博客\n规范内容 # Commit信息格式 # \u0026lt;type\u0026gt;(\u0026lt;scope\u0026gt;): \u0026lt;subject\u0026gt; \u0026lt;BLANK LINE\u0026gt; \u0026lt;body\u0026gt; \u0026lt;BLANK LINE\u0026gt; \u0026lt;footer\u0026gt; 其中type(提交类型)和subject(简短描述)是必须项，scope(影响范围)是可选项 第一行为Header(标题)，第二部分为Body(正文)，最后部分为Footer(脚注) 一般实际开发中主要遵循标题规范，即 type(scope): subject，示例如下\nfeat(第二课堂): 显示第二课堂学分 fix(第二课堂): 修复第二课堂学分显示问题 docs: Readme中增加新人环境配置教程 test: 教务系统API单元测试 Type (提交类型) # 常用的Type类型如下：\nfeat: 新功能 fix: 修复 bug docs: 文档修改 style: 不影响代码逻辑的格式调整 refactor: 既不是新功能也不是修复 bug 的代码重构 perf: 性能优化 test: 添加或修改测试代码 chore: 构建过程或辅助工具的变动 Scope (影响范围) # 指定提交影响的模块或文件范围，例如：\n第二课堂 教务系统 Subject (简短描述) # 建议使用中文 简单描述修改内容，使用陈述句，例如\u0026quot;修复了xx问题\u0026quot; 结尾不要使用句号或者其他标点符号 规范Git Commit工具 # 使用VSCode的用户可以安装git-commit-plugin插件，使用效果如下： ","date":"2025-09-24","externalUrl":null,"permalink":"/posts/git/gitcommit/","section":"文章","summary":"介绍最广泛的Angular Git Commit提交规范","title":"Git Commit规范","type":"posts"},{"content":"","date":"2025-09-24","externalUrl":null,"permalink":"/tags/%E6%8A%80%E6%9C%AF%E8%A7%84%E8%8C%83/","section":"Tags","summary":"","title":"技术规范","type":"tags"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":" 我的QQ # 2404580981\n我的微信 # ","externalUrl":null,"permalink":"/users/","section":"欢迎来到 Blowfish ！","summary":"","title":"关于我","type":"page"}]