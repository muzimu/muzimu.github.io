[{"content":"","date":"2025-09-09","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"Golang后端开发程序员\n","date":"2025-09-09","externalUrl":null,"permalink":"/","section":"欢迎来到 Blowfish ！","summary":"","title":"欢迎来到 Blowfish ！","type":"page"},{"content":" 1. Vue3简介 # 2020年9月18日，Vue.js发布版3.0版本，代号：One Piece（n\n经历了：4800+次提交、40+个RFC、600+次PR、300+贡献者\n官方发版地址：Release v3.0.0 One Piece · vuejs/core\n截止2023年10月，最新的公开版本为：3.3.4\n1.1. 【性能的提升】 # 打包大小减少41%。\n初次渲染快55%, 更新渲染快133%。\n内存减少54%。\n1.2.【 源码的升级】 # 使用Proxy代替defineProperty实现响应式。\n重写虚拟DOM的实现和Tree-Shaking。\n1.3. 【拥抱TypeScript】 # Vue3可以更好的支持TypeScript。 1.4. 【新的特性】 # Composition API（组合API）：\nsetup\nref与reactive\ncomputed与watch\n\u0026hellip;\u0026hellip;\n新的内置组件：\nFragment\nTeleport\nSuspense\n\u0026hellip;\u0026hellip;\n其他改变：\n新的生命周期钩子\ndata 选项应始终被声明为一个函数\n移除keyCode支持作为 v-on 的修饰符\n\u0026hellip;\u0026hellip;\n2. 创建Vue3工程 # 2.1. 【基于 vue-cli 创建】 # 点击查看官方文档\n备注：目前vue-cli已处于维护模式，官方推荐基于 Vite 创建项目。\n## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上 vue --version ## 安装或者升级你的@vue/cli npm install -g @vue/cli ## 执行创建命令 vue create vue_test ## 随后选择3.x ## Choose a version of Vue.js that you want to start the project with (Use arrow keys) ## \u0026gt; 3.x ## 2.x ## 启动 cd vue_test npm run serve 2.2. 【基于 vite 创建】(推荐) # vite 是新一代前端构建工具，官网地址：https://vitejs.cn，vite的优势如下：\n轻量快速的热重载（HMR），能实现极速的服务启动。 对 TypeScript、JSX、CSS 等支持开箱即用。 真正的按需编译，不再等待整个应用编译完成。 webpack构建 与 vite构建对比图如下： 具体操作如下（点击查看官方文档） ## 1.创建命令 npm create vue@latest ## 2.具体配置 ## 配置项目名称 √ Project name: vue3_test ## 是否添加TypeScript支持 √ Add TypeScript? Yes ## 是否添加JSX支持 √ Add JSX Support? No ## 是否添加路由环境 √ Add Vue Router for Single Page Application development? No ## 是否添加pinia环境 √ Add Pinia for state management? No ## 是否添加单元测试 √ Add Vitest for Unit Testing? No ## 是否添加端到端测试方案 √ Add an End-to-End Testing Solution? » No ## 是否添加ESLint语法检查 √ Add ESLint for code quality? Yes ## 是否添加Prettiert代码格式化 √ Add Prettier for code formatting? No 自己动手编写一个App组件\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;你好啊！\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; export default { name:\u0026#39;App\u0026#39; //组件名 } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .app { background-color: #ddd; box-shadow: 0 0 10px; border-radius: 10px; padding: 20px; } \u0026lt;/style\u0026gt; 安装官方推荐的vscode插件：\n总结：\nVite 项目中，index.html 是项目的入口文件，在项目最外层。 加载index.html后，Vite 解析 \u0026lt;script type=\u0026quot;module\u0026quot; src=\u0026quot;xxx\u0026quot;\u0026gt; 指向的JavaScript。 Vue3**中是通过 **createApp 函数创建一个应用实例。 2.3. 【一个简单的效果】 # Vue3向下兼容Vue2语法，且Vue3中的模板中可以没有根标签\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;姓名：{{name}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;年龄：{{age}}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changeName\u0026#34;\u0026gt;修改名字\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeAge\u0026#34;\u0026gt;年龄+1\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;showTel\u0026#34;\u0026gt;点我查看联系方式\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; export default { name:\u0026#39;App\u0026#39;, data() { return { name:\u0026#39;张三\u0026#39;, age:18, tel:\u0026#39;13888888888\u0026#39; } }, methods:{ changeName(){ this.name = \u0026#39;zhang-san\u0026#39; }, changeAge(){ this.age += 1 }, showTel(){ alert(this.tel) } }, } \u0026lt;/script\u0026gt; 3. Vue3核心语法 # 3.1. 【OptionsAPI 与 CompositionAPI】 # Vue2的API设计是Options（配置）风格的。 Vue3的API设计是Composition（组合）风格的。 Options API 的弊端 # Options类型的 API，数据、方法、计算属性等，是分散在：data、methods、computed中的，若想新增或者修改一个需求，就需要分别修改：data、methods、computed，不便于维护和复用。\nComposition API 的优势 # 可以用函数的方式，更加优雅的组织代码，让相关功能的代码更加有序的组织在一起。\n说明：以上四张动图原创作者：大帅老猿\n3.2. 【拉开序幕的 setup】 # setup 概述 # setup是Vue3中一个新的配置项，值是一个函数，它是 Composition API “表演的舞台”，组件中所用到的：数据、方法、计算属性、监视\u0026hellip;\u0026hellip;等等，均配置在setup中。\n特点如下：\nsetup函数返回的对象中的内容，可直接在模板中使用。 setup中访问this是undefined。 setup函数会在beforeCreate之前调用，它是“领先”所有钩子执行的。 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;姓名：{{name}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;年龄：{{age}}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changeName\u0026#34;\u0026gt;修改名字\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeAge\u0026#34;\u0026gt;年龄+1\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;showTel\u0026#34;\u0026gt;点我查看联系方式\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; export default { name:\u0026#39;Person\u0026#39;, setup(){ // 数据，原来写在data中（注意：此时的name、age、tel数据都不是响应式数据） let name = \u0026#39;张三\u0026#39; let age = 18 let tel = \u0026#39;13888888888\u0026#39; // 方法，原来写在methods中 function changeName(){ name = \u0026#39;zhang-san\u0026#39; //注意：此时这么修改name页面是不变化的 console.log(name) } function changeAge(){ age += 1 //注意：此时这么修改age页面是不变化的 console.log(age) } function showTel(){ alert(tel) } // 返回一个对象，对象中的内容，模板中可以直接使用 return {name,age,tel,changeName,changeAge,showTel} } } \u0026lt;/script\u0026gt; setup 的返回值 # 若返回一个对象：则对象中的：属性、方法等，在模板中均可以直接使用**（重点关注）。** 若返回一个函数：则可以自定义渲染内容，代码如下： setup(){ return ()=\u0026gt; \u0026#39;你好啊！\u0026#39; } setup 与 Options API 的关系 # Vue2 的配置（data、methos\u0026hellip;\u0026hellip;）中可以访问到 setup中的属性、方法。 但在setup中不能访问到Vue2的配置（data、methos\u0026hellip;\u0026hellip;）。 如果与Vue2冲突，则setup优先。 setup 语法糖 # setup函数有一个语法糖，这个语法糖，可以让我们把setup独立出去，代码如下：\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;姓名：{{name}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;年龄：{{age}}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changName\u0026#34;\u0026gt;修改名字\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changAge\u0026#34;\u0026gt;年龄+1\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;showTel\u0026#34;\u0026gt;点我查看联系方式\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; export default { name:\u0026#39;Person\u0026#39;, } \u0026lt;/script\u0026gt; \u0026lt;!-- 下面的写法是setup语法糖 --\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; console.log(this) //undefined // 数据（注意：此时的name、age、tel都不是响应式数据） let name = \u0026#39;张三\u0026#39; let age = 18 let tel = \u0026#39;13888888888\u0026#39; // 方法 function changName(){ name = \u0026#39;李四\u0026#39;//注意：此时这么修改name页面是不变化的 } function changAge(){ console.log(age) age += 1 //注意：此时这么修改age页面是不变化的 } function showTel(){ alert(tel) } \u0026lt;/script\u0026gt; 扩展：上述代码，还需要编写一个不写setup的script标签，去指定组件名字，比较麻烦，我们可以借助vite中的插件简化\n第一步：npm i vite-plugin-vue-setup-extend -D 第二步：vite.config.ts import { defineConfig } from \u0026#39;vite\u0026#39; import VueSetupExtend from \u0026#39;vite-plugin-vue-setup-extend\u0026#39; export default defineConfig({ plugins: [ VueSetupExtend() ] }) 第三步：\u0026lt;script setup lang=\u0026quot;ts\u0026quot; name=\u0026quot;Person\u0026quot;\u0026gt; 3.3. 【ref 创建：基本类型的响应式数据】 # **作用：**定义响应式变量。 语法：let xxx = ref(初始值)。 **返回值：**一个RefImpl的实例对象，简称ref对象或ref，ref对象的value属性是响应式的。 注意点： JS中操作数据需要：xxx.value，但模板中不需要.value，直接使用即可。 对于let name = ref('张三')来说，name不是响应式的，name.value是响应式的。 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;姓名：{{name}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;年龄：{{age}}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changeName\u0026#34;\u0026gt;修改名字\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeAge\u0026#34;\u0026gt;年龄+1\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;showTel\u0026#34;\u0026gt;点我查看联系方式\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;Person\u0026#34;\u0026gt; import {ref} from \u0026#39;vue\u0026#39; // name和age是一个RefImpl的实例对象，简称ref对象，它们的value属性是响应式的。 let name = ref(\u0026#39;张三\u0026#39;) let age = ref(18) // tel就是一个普通的字符串，不是响应式的 let tel = \u0026#39;13888888888\u0026#39; function changeName(){ // JS中操作ref对象时候需要.value name.value = \u0026#39;李四\u0026#39; console.log(name.value) // 注意：name不是响应式的，name.value是响应式的，所以如下代码并不会引起页面的更新。 // name = ref(\u0026#39;zhang-san\u0026#39;) } function changeAge(){ // JS中操作ref对象时候需要.value age.value += 1 console.log(age.value) } function showTel(){ alert(tel) } \u0026lt;/script\u0026gt; 3.4. 【reactive 创建：对象类型的响应式数据】 # 作用：定义一个响应式对象（基本类型不要用它，要用ref，否则报错） 语法：let 响应式对象= reactive(源对象)。 **返回值：**一个Proxy的实例对象，简称：响应式对象。 注意点：reactive定义的响应式数据是“深层次”的。 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;汽车信息：一台{{ car.brand }}汽车，价值{{ car.price }}万\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;游戏列表：\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;g in games\u0026#34; :key=\u0026#34;g.id\u0026#34;\u0026gt;{{ g.name }}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;h2\u0026gt;测试：{{obj.a.b.c.d}}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changeCarPrice\u0026#34;\u0026gt;修改汽车价格\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeFirstGame\u0026#34;\u0026gt;修改第一游戏\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;test\u0026#34;\u0026gt;测试\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup name=\u0026#34;Person\u0026#34;\u0026gt; import { reactive } from \u0026#39;vue\u0026#39; // 数据 let car = reactive({ brand: \u0026#39;奔驰\u0026#39;, price: 100 }) let games = reactive([ { id: \u0026#39;ahsgdyfa01\u0026#39;, name: \u0026#39;英雄联盟\u0026#39; }, { id: \u0026#39;ahsgdyfa02\u0026#39;, name: \u0026#39;王者荣耀\u0026#39; }, { id: \u0026#39;ahsgdyfa03\u0026#39;, name: \u0026#39;原神\u0026#39; } ]) let obj = reactive({ a:{ b:{ c:{ d:666 } } } }) function changeCarPrice() { car.price += 10 } function changeFirstGame() { games[0].name = \u0026#39;流星蝴蝶剑\u0026#39; } function test(){ obj.a.b.c.d = 999 } \u0026lt;/script\u0026gt; 3.5. 【ref 创建：对象类型的响应式数据】 # 其实ref接收的数据可以是：基本类型、对象类型。 若ref接收的是对象类型，内部其实也是调用了reactive函数。 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;汽车信息：一台{{ car.brand }}汽车，价值{{ car.price }}万\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;游戏列表：\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;g in games\u0026#34; :key=\u0026#34;g.id\u0026#34;\u0026gt;{{ g.name }}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;h2\u0026gt;测试：{{obj.a.b.c.d}}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changeCarPrice\u0026#34;\u0026gt;修改汽车价格\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeFirstGame\u0026#34;\u0026gt;修改第一游戏\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;test\u0026#34;\u0026gt;测试\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup name=\u0026#34;Person\u0026#34;\u0026gt; import { ref } from \u0026#39;vue\u0026#39; // 数据 let car = ref({ brand: \u0026#39;奔驰\u0026#39;, price: 100 }) let games = ref([ { id: \u0026#39;ahsgdyfa01\u0026#39;, name: \u0026#39;英雄联盟\u0026#39; }, { id: \u0026#39;ahsgdyfa02\u0026#39;, name: \u0026#39;王者荣耀\u0026#39; }, { id: \u0026#39;ahsgdyfa03\u0026#39;, name: \u0026#39;原神\u0026#39; } ]) let obj = ref({ a:{ b:{ c:{ d:666 } } } }) console.log(car) function changeCarPrice() { car.value.price += 10 } function changeFirstGame() { games.value[0].name = \u0026#39;流星蝴蝶剑\u0026#39; } function test(){ obj.value.a.b.c.d = 999 } \u0026lt;/script\u0026gt; 3.6. 【ref 对比 reactive】 # 宏观角度看：\nref用来定义：基本类型数据、对象类型数据；\nreactive用来定义：对象类型数据。\n区别： ref创建的变量必须使用.value（可以使用volar插件自动添加.value）。\nreactive重新分配一个新对象，会失去响应式（可以使用Object.assign去整体替换）。\n使用原则： 若需要一个基本类型的响应式数据，必须使用ref。 若需要一个响应式对象，层级不深，ref、reactive都可以。 若需要一个响应式对象，且层级较深，推荐使用reactive。 3.7. 【toRefs 与 toRef】 # 作用：将一个响应式对象中的每一个属性，转换为ref对象。 备注：toRefs与toRef功能一致，但toRefs可以批量转换。 语法如下： \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;姓名：{{person.name}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;年龄：{{person.age}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;性别：{{person.gender}}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changeName\u0026#34;\u0026gt;修改名字\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeAge\u0026#34;\u0026gt;修改年龄\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeGender\u0026#34;\u0026gt;修改性别\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup name=\u0026#34;Person\u0026#34;\u0026gt; import {ref,reactive,toRefs,toRef} from \u0026#39;vue\u0026#39; // 数据 let person = reactive({name:\u0026#39;张三\u0026#39;, age:18, gender:\u0026#39;男\u0026#39;}) // 通过toRefs将person对象中的n个属性批量取出，且依然保持响应式的能力 let {name,gender} = toRefs(person) // 通过toRef将person对象中的gender属性取出，且依然保持响应式的能力 let age = toRef(person,\u0026#39;age\u0026#39;) // 方法 function changeName(){ name.value += \u0026#39;~\u0026#39; } function changeAge(){ age.value += 1 } function changeGender(){ gender.value = \u0026#39;女\u0026#39; } \u0026lt;/script\u0026gt; 3.8. 【computed】 # 作用：根据已有数据计算出新数据（和Vue2中的computed作用一致）。\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; 姓：\u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;firstName\u0026#34;\u0026gt; \u0026lt;br\u0026gt; 名：\u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;lastName\u0026#34;\u0026gt; \u0026lt;br\u0026gt; 全名：\u0026lt;span\u0026gt;{{fullName}}\u0026lt;/span\u0026gt; \u0026lt;br\u0026gt; \u0026lt;button @click=\u0026#34;changeFullName\u0026#34;\u0026gt;全名改为：li-si\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;App\u0026#34;\u0026gt; import {ref,computed} from \u0026#39;vue\u0026#39; let firstName = ref(\u0026#39;zhang\u0026#39;) let lastName = ref(\u0026#39;san\u0026#39;) // 计算属性——只读取，不修改 /* let fullName = computed(()=\u0026gt;{ return firstName.value + \u0026#39;-\u0026#39; + lastName.value }) */ // 计算属性——既读取又修改 let fullName = computed({ // 读取 get(){ return firstName.value + \u0026#39;-\u0026#39; + lastName.value }, // 修改 set(val){ console.log(\u0026#39;有人修改了fullName\u0026#39;,val) firstName.value = val.split(\u0026#39;-\u0026#39;)[0] lastName.value = val.split(\u0026#39;-\u0026#39;)[1] } }) function changeFullName(){ fullName.value = \u0026#39;li-si\u0026#39; } \u0026lt;/script\u0026gt; 3.9.【watch】 # 作用：监视数据的变化（和Vue2中的watch作用一致） 特点：Vue3中的watch只能监视以下四种数据： ref定义的数据。 reactive定义的数据。 函数返回一个值（getter函数）。 一个包含上述内容的数组。 我们在Vue3中使用watch的时候，通常会遇到以下几种情况：\n* 情况一 # 监视ref定义的【基本类型】数据：直接写数据名即可，监视的是其value值的改变。\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;情况一：监视【ref】定义的【基本类型】数据\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;当前求和为：{{sum}}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changeSum\u0026#34;\u0026gt;点我sum+1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup name=\u0026#34;Person\u0026#34;\u0026gt; import {ref,watch} from \u0026#39;vue\u0026#39; // 数据 let sum = ref(0) // 方法 function changeSum(){ sum.value += 1 } // 监视，情况一：监视【ref】定义的【基本类型】数据 const stopWatch = watch(sum,(newValue,oldValue)=\u0026gt;{ console.log(\u0026#39;sum变化了\u0026#39;,newValue,oldValue) if(newValue \u0026gt;= 10){ stopWatch() } }) \u0026lt;/script\u0026gt; * 情况二 # 监视ref定义的【对象类型】数据：直接写数据名，监视的是对象的【地址值】，若想监视对象内部的数据，要手动开启深度监视。\n注意：\n若修改的是ref定义的对象中的属性，newValue 和 oldValue 都是新值，因为它们是同一个对象。\n若修改整个ref定义的对象，newValue 是新值， oldValue 是旧值，因为不是同一个对象了。\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;情况二：监视【ref】定义的【对象类型】数据\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;姓名：{{ person.name }}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;年龄：{{ person.age }}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changeName\u0026#34;\u0026gt;修改名字\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeAge\u0026#34;\u0026gt;修改年龄\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changePerson\u0026#34;\u0026gt;修改整个人\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup name=\u0026#34;Person\u0026#34;\u0026gt; import {ref,watch} from \u0026#39;vue\u0026#39; // 数据 let person = ref({ name:\u0026#39;张三\u0026#39;, age:18 }) // 方法 function changeName(){ person.value.name += \u0026#39;~\u0026#39; } function changeAge(){ person.value.age += 1 } function changePerson(){ person.value = {name:\u0026#39;李四\u0026#39;,age:90} } /* 监视，情况一：监视【ref】定义的【对象类型】数据，监视的是对象的地址值，若想监视对象内部属性的变化，需要手动开启深度监视 watch的第一个参数是：被监视的数据 watch的第二个参数是：监视的回调 watch的第三个参数是：配置对象（deep、immediate等等.....） */ watch(person,(newValue,oldValue)=\u0026gt;{ console.log(\u0026#39;person变化了\u0026#39;,newValue,oldValue) },{deep:true}) \u0026lt;/script\u0026gt; * 情况三 # 监视reactive定义的【对象类型】数据，且默认开启了深度监视。\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;情况三：监视【reactive】定义的【对象类型】数据\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;姓名：{{ person.name }}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;年龄：{{ person.age }}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changeName\u0026#34;\u0026gt;修改名字\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeAge\u0026#34;\u0026gt;修改年龄\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changePerson\u0026#34;\u0026gt;修改整个人\u0026lt;/button\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;h2\u0026gt;测试：{{obj.a.b.c}}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;test\u0026#34;\u0026gt;修改obj.a.b.c\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup name=\u0026#34;Person\u0026#34;\u0026gt; import {reactive,watch} from \u0026#39;vue\u0026#39; // 数据 let person = reactive({ name:\u0026#39;张三\u0026#39;, age:18 }) let obj = reactive({ a:{ b:{ c:666 } } }) // 方法 function changeName(){ person.name += \u0026#39;~\u0026#39; } function changeAge(){ person.age += 1 } function changePerson(){ Object.assign(person,{name:\u0026#39;李四\u0026#39;,age:80}) } function test(){ obj.a.b.c = 888 } // 监视，情况三：监视【reactive】定义的【对象类型】数据，且默认是开启深度监视的 watch(person,(newValue,oldValue)=\u0026gt;{ console.log(\u0026#39;person变化了\u0026#39;,newValue,oldValue) }) watch(obj,(newValue,oldValue)=\u0026gt;{ console.log(\u0026#39;Obj变化了\u0026#39;,newValue,oldValue) }) \u0026lt;/script\u0026gt; * 情况四 # 监视ref或reactive定义的【对象类型】数据中的某个属性，注意点如下：\n若该属性值不是【对象类型】，需要写成函数形式。 若该属性值是依然是【对象类型】，可直接编，也可写成函数，建议写成函数。 结论：监视的要是对象里的属性，那么最好写函数式，注意点：若是对象监视的是地址值，需要关注对象内部，需要手动开启深度监视。\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;情况四：监视【ref】或【reactive】定义的【对象类型】数据中的某个属性\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;姓名：{{ person.name }}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;年龄：{{ person.age }}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;汽车：{{ person.car.c1 }}、{{ person.car.c2 }}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changeName\u0026#34;\u0026gt;修改名字\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeAge\u0026#34;\u0026gt;修改年龄\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeC1\u0026#34;\u0026gt;修改第一台车\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeC2\u0026#34;\u0026gt;修改第二台车\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeCar\u0026#34;\u0026gt;修改整个车\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup name=\u0026#34;Person\u0026#34;\u0026gt; import {reactive,watch} from \u0026#39;vue\u0026#39; // 数据 let person = reactive({ name:\u0026#39;张三\u0026#39;, age:18, car:{ c1:\u0026#39;奔驰\u0026#39;, c2:\u0026#39;宝马\u0026#39; } }) // 方法 function changeName(){ person.name += \u0026#39;~\u0026#39; } function changeAge(){ person.age += 1 } function changeC1(){ person.car.c1 = \u0026#39;奥迪\u0026#39; } function changeC2(){ person.car.c2 = \u0026#39;大众\u0026#39; } function changeCar(){ person.car = {c1:\u0026#39;雅迪\u0026#39;,c2:\u0026#39;爱玛\u0026#39;} } // 监视，情况四：监视响应式对象中的某个属性，且该属性是基本类型的，要写成函数式 /* watch(()=\u0026gt; person.name,(newValue,oldValue)=\u0026gt;{ console.log(\u0026#39;person.name变化了\u0026#39;,newValue,oldValue) }) */ // 监视，情况四：监视响应式对象中的某个属性，且该属性是对象类型的，可以直接写，也能写函数，更推荐写函数 watch(()=\u0026gt;person.car,(newValue,oldValue)=\u0026gt;{ console.log(\u0026#39;person.car变化了\u0026#39;,newValue,oldValue) },{deep:true}) \u0026lt;/script\u0026gt; * 情况五 # 监视上述的多个数据\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;情况五：监视上述的多个数据\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;姓名：{{ person.name }}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;年龄：{{ person.age }}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;汽车：{{ person.car.c1 }}、{{ person.car.c2 }}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changeName\u0026#34;\u0026gt;修改名字\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeAge\u0026#34;\u0026gt;修改年龄\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeC1\u0026#34;\u0026gt;修改第一台车\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeC2\u0026#34;\u0026gt;修改第二台车\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeCar\u0026#34;\u0026gt;修改整个车\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup name=\u0026#34;Person\u0026#34;\u0026gt; import {reactive,watch} from \u0026#39;vue\u0026#39; // 数据 let person = reactive({ name:\u0026#39;张三\u0026#39;, age:18, car:{ c1:\u0026#39;奔驰\u0026#39;, c2:\u0026#39;宝马\u0026#39; } }) // 方法 function changeName(){ person.name += \u0026#39;~\u0026#39; } function changeAge(){ person.age += 1 } function changeC1(){ person.car.c1 = \u0026#39;奥迪\u0026#39; } function changeC2(){ person.car.c2 = \u0026#39;大众\u0026#39; } function changeCar(){ person.car = {c1:\u0026#39;雅迪\u0026#39;,c2:\u0026#39;爱玛\u0026#39;} } // 监视，情况五：监视上述的多个数据 watch([()=\u0026gt;person.name,person.car],(newValue,oldValue)=\u0026gt;{ console.log(\u0026#39;person.car变化了\u0026#39;,newValue,oldValue) },{deep:true}) \u0026lt;/script\u0026gt; 3.10. 【watchEffect】 # 官网：立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行该函数。\nwatch对比watchEffect\n都能监听响应式数据的变化，不同的是监听数据变化的方式不同\nwatch：要明确指出监视的数据\nwatchEffect：不用明确指出监视的数据（函数中用到哪些属性，那就监视哪些属性）。\n示例代码：\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;需求：水温达到50℃，或水位达到20cm，则联系服务器\u0026lt;/h1\u0026gt; \u0026lt;h2 id=\u0026#34;demo\u0026#34;\u0026gt;水温：{{temp}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;水位：{{height}}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changePrice\u0026#34;\u0026gt;水温+1\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeSum\u0026#34;\u0026gt;水位+10\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup name=\u0026#34;Person\u0026#34;\u0026gt; import {ref,watch,watchEffect} from \u0026#39;vue\u0026#39; // 数据 let temp = ref(0) let height = ref(0) // 方法 function changePrice(){ temp.value += 10 } function changeSum(){ height.value += 1 } // 用watch实现，需要明确的指出要监视：temp、height watch([temp,height],(value)=\u0026gt;{ // 从value中获取最新的temp值、height值 const [newTemp,newHeight] = value // 室温达到50℃，或水位达到20cm，立刻联系服务器 if(newTemp \u0026gt;= 50 || newHeight \u0026gt;= 20){ console.log(\u0026#39;联系服务器\u0026#39;) } }) // 用watchEffect实现，不用 const stopWtach = watchEffect(()=\u0026gt;{ // 室温达到50℃，或水位达到20cm，立刻联系服务器 if(temp.value \u0026gt;= 50 || height.value \u0026gt;= 20){ console.log(document.getElementById(\u0026#39;demo\u0026#39;)?.innerText) console.log(\u0026#39;联系服务器\u0026#39;) } // 水温达到100，或水位达到50，取消监视 if(temp.value === 100 || height.value === 50){ console.log(\u0026#39;清理了\u0026#39;) stopWtach() } }) \u0026lt;/script\u0026gt; 3.11. 【标签的 ref 属性】 # 作用：用于注册模板引用。\n用在普通DOM标签上，获取的是DOM节点。\n用在组件标签上，获取的是组件实例对象。\n用在普通DOM标签上：\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; \u0026lt;h1 ref=\u0026#34;title1\u0026#34;\u0026gt;尚硅谷\u0026lt;/h1\u0026gt; \u0026lt;h2 ref=\u0026#34;title2\u0026#34;\u0026gt;前端\u0026lt;/h2\u0026gt; \u0026lt;h3 ref=\u0026#34;title3\u0026#34;\u0026gt;Vue\u0026lt;/h3\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; ref=\u0026#34;inpt\u0026#34;\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;button @click=\u0026#34;showLog\u0026#34;\u0026gt;点我打印内容\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup name=\u0026#34;Person\u0026#34;\u0026gt; import {ref} from \u0026#39;vue\u0026#39; let title1 = ref() let title2 = ref() let title3 = ref() function showLog(){ // 通过id获取元素 const t1 = document.getElementById(\u0026#39;title1\u0026#39;) // 打印内容 console.log((t1 as HTMLElement).innerText) console.log((\u0026lt;HTMLElement\u0026gt;t1).innerText) console.log(t1?.innerText) /************************************/ // 通过ref获取元素 console.log(title1.value) console.log(title2.value) console.log(title3.value) } \u0026lt;/script\u0026gt; 用在组件标签上：\n\u0026lt;!-- 父组件App.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;Person ref=\u0026#34;ren\u0026#34;/\u0026gt; \u0026lt;button @click=\u0026#34;test\u0026#34;\u0026gt;测试\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup name=\u0026#34;App\u0026#34;\u0026gt; import Person from \u0026#39;./components/Person.vue\u0026#39; import {ref} from \u0026#39;vue\u0026#39; let ren = ref() function test(){ console.log(ren.value.name) console.log(ren.value.age) } \u0026lt;/script\u0026gt; \u0026lt;!-- 子组件Person.vue中要使用defineExpose暴露内容 --\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup name=\u0026#34;Person\u0026#34;\u0026gt; import {ref,defineExpose} from \u0026#39;vue\u0026#39; // 数据 let name = ref(\u0026#39;张三\u0026#39;) let age = ref(18) /****************************/ /****************************/ // 使用defineExpose将组件中的数据交给外部 defineExpose({name,age}) \u0026lt;/script\u0026gt; 3.12. 【props】 # // 定义一个接口，限制每个Person对象的格式 export interface PersonInter { id:string, name:string, age:number } // 定义一个自定义类型Persons export type Persons = Array\u0026lt;PersonInter\u0026gt; App.vue中代码：\n\u0026lt;template\u0026gt; \u0026lt;Person :list=\u0026#34;persons\u0026#34;/\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup name=\u0026#34;App\u0026#34;\u0026gt; import Person from \u0026#39;./components/Person.vue\u0026#39; import {reactive} from \u0026#39;vue\u0026#39; import {type Persons} from \u0026#39;./types\u0026#39; let persons = reactive\u0026lt;Persons\u0026gt;([ {id:\u0026#39;e98219e12\u0026#39;,name:\u0026#39;张三\u0026#39;,age:18}, {id:\u0026#39;e98219e13\u0026#39;,name:\u0026#39;李四\u0026#39;,age:19}, {id:\u0026#39;e98219e14\u0026#39;,name:\u0026#39;王五\u0026#39;,age:20} ]) \u0026lt;/script\u0026gt; Person.vue中代码：\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;item in list\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt; {{item.name}}--{{item.age}} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup name=\u0026#34;Person\u0026#34;\u0026gt; import {defineProps} from \u0026#39;vue\u0026#39; import {type PersonInter} from \u0026#39;@/types\u0026#39; // 第一种写法：仅接收 // const props = defineProps([\u0026#39;list\u0026#39;]) // 第二种写法：接收+限制类型 // defineProps\u0026lt;{list:Persons}\u0026gt;() // 第三种写法：接收+限制类型+指定默认值+限制必要性 let props = withDefaults(defineProps\u0026lt;{list?:Persons}\u0026gt;(),{ list:()=\u0026gt;[{id:\u0026#39;asdasg01\u0026#39;,name:\u0026#39;小猪佩奇\u0026#39;,age:18}] }) console.log(props) \u0026lt;/script\u0026gt; 3.13. 【生命周期】 # 概念：Vue组件实例在创建时要经历一系列的初始化步骤，在此过程中Vue会在合适的时机，调用特定的函数，从而让开发者有机会在特定阶段运行自己的代码，这些特定的函数统称为：生命周期钩子\n规律：\n生命周期整体分为四个阶段，分别是：创建、挂载、更新、销毁，每个阶段都有两个钩子，一前一后。\nVue2的生命周期\n创建阶段：beforeCreate、created\n挂载阶段：beforeMount、mounted\n更新阶段：beforeUpdate、updated\n销毁阶段：beforeDestroy、destroyed\nVue3的生命周期\n创建阶段：setup\n挂载阶段：onBeforeMount、onMounted\n更新阶段：onBeforeUpdate、onUpdated\n卸载阶段：onBeforeUnmount、onUnmounted\n常用的钩子：onMounted(挂载完毕)、onUpdated(更新完毕)、onBeforeUnmount(卸载之前)\n示例代码：\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;当前求和为：{{ sum }}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changeSum\u0026#34;\u0026gt;点我sum+1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;!-- vue3写法 --\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup name=\u0026#34;Person\u0026#34;\u0026gt; import { ref, onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted } from \u0026#39;vue\u0026#39; // 数据 let sum = ref(0) // 方法 function changeSum() { sum.value += 1 } console.log(\u0026#39;setup\u0026#39;) // 生命周期钩子 onBeforeMount(()=\u0026gt;{ console.log(\u0026#39;挂载之前\u0026#39;) }) onMounted(()=\u0026gt;{ console.log(\u0026#39;挂载完毕\u0026#39;) }) onBeforeUpdate(()=\u0026gt;{ console.log(\u0026#39;更新之前\u0026#39;) }) onUpdated(()=\u0026gt;{ console.log(\u0026#39;更新完毕\u0026#39;) }) onBeforeUnmount(()=\u0026gt;{ console.log(\u0026#39;卸载之前\u0026#39;) }) onUnmounted(()=\u0026gt;{ console.log(\u0026#39;卸载完毕\u0026#39;) }) \u0026lt;/script\u0026gt; 3.14. 【自定义hook】 # 什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装，类似于vue2.x中的mixin。\n自定义hook的优势：复用代码, 让setup中的逻辑更清楚易懂。\n示例代码：\nuseSum.ts中内容如下：\nimport {ref,onMounted} from \u0026#39;vue\u0026#39; export default function(){ let sum = ref(0) const increment = ()=\u0026gt;{ sum.value += 1 } const decrement = ()=\u0026gt;{ sum.value -= 1 } onMounted(()=\u0026gt;{ increment() }) //向外部暴露数据 return {sum,increment,decrement} }\tuseDog.ts中内容如下：\nimport {reactive,onMounted} from \u0026#39;vue\u0026#39; import axios,{AxiosError} from \u0026#39;axios\u0026#39; export default function(){ let dogList = reactive\u0026lt;string[]\u0026gt;([]) // 方法 async function getDog(){ try { // 发请求 let {data} = await axios.get(\u0026#39;https://dog.ceo/api/breed/pembroke/images/random\u0026#39;) // 维护数据 dogList.push(data.message) } catch (error) { // 处理错误 const err = \u0026lt;AxiosError\u0026gt;error console.log(err.message) } } // 挂载钩子 onMounted(()=\u0026gt;{ getDog() }) //向外部暴露数据 return {dogList,getDog} } 组件中具体使用：\n\u0026lt;template\u0026gt; \u0026lt;h2\u0026gt;当前求和为：{{sum}}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;点我+1\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;decrement\u0026#34;\u0026gt;点我-1\u0026lt;/button\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;img v-for=\u0026#34;(u,index) in dogList.urlList\u0026#34; :key=\u0026#34;index\u0026#34; :src=\u0026#34;(u as string)\u0026#34;\u0026gt; \u0026lt;span v-show=\u0026#34;dogList.isLoading\u0026#34;\u0026gt;加载中......\u0026lt;/span\u0026gt;\u0026lt;br\u0026gt; \u0026lt;button @click=\u0026#34;getDog\u0026#34;\u0026gt;再来一只狗\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import {defineComponent} from \u0026#39;vue\u0026#39; export default defineComponent({ name:\u0026#39;App\u0026#39;, }) \u0026lt;/script\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import useSum from \u0026#39;./hooks/useSum\u0026#39; import useDog from \u0026#39;./hooks/useDog\u0026#39; let {sum,increment,decrement} = useSum() let {dogList,getDog} = useDog() \u0026lt;/script\u0026gt; 4. 路由 # 4.1. 【对路由的理解】 # 4.2. 【基本切换效果】 # Vue3中要使用vue-router的最新版本，目前是4版本。\n路由配置文件代码如下：\nimport {createRouter,createWebHistory} from \u0026#39;vue-router\u0026#39; import Home from \u0026#39;@/pages/Home.vue\u0026#39; import News from \u0026#39;@/pages/News.vue\u0026#39; import About from \u0026#39;@/pages/About.vue\u0026#39; const router = createRouter({ history:createWebHistory(), routes:[ { path:\u0026#39;/home\u0026#39;, component:Home }, { path:\u0026#39;/about\u0026#39;, component:About } ] }) export default router main.ts代码如下：\nimport router from \u0026#39;./router/index\u0026#39; app.use(router) app.mount(\u0026#39;#app\u0026#39;) App.vue代码如下\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h2 class=\u0026#34;title\u0026#34;\u0026gt;Vue路由测试\u0026lt;/h2\u0026gt; \u0026lt;!-- 导航区 --\u0026gt; \u0026lt;div class=\u0026#34;navigate\u0026#34;\u0026gt; \u0026lt;RouterLink to=\u0026#34;/home\u0026#34; active-class=\u0026#34;active\u0026#34;\u0026gt;首页\u0026lt;/RouterLink\u0026gt; \u0026lt;RouterLink to=\u0026#34;/news\u0026#34; active-class=\u0026#34;active\u0026#34;\u0026gt;新闻\u0026lt;/RouterLink\u0026gt; \u0026lt;RouterLink to=\u0026#34;/about\u0026#34; active-class=\u0026#34;active\u0026#34;\u0026gt;关于\u0026lt;/RouterLink\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 展示区 --\u0026gt; \u0026lt;div class=\u0026#34;main-content\u0026#34;\u0026gt; \u0026lt;RouterView\u0026gt;\u0026lt;/RouterView\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup name=\u0026#34;App\u0026#34;\u0026gt; import {RouterLink,RouterView} from \u0026#39;vue-router\u0026#39; \u0026lt;/script\u0026gt; 4.3. 【两个注意点】 # 路由组件通常存放在pages 或 views文件夹，一般组件通常存放在components文件夹。\n通过点击导航，视觉效果上“消失” 了的路由组件，默认是被卸载掉的，需要的时候再去挂载。\n4.4.【路由器工作模式】 # history模式\n优点：URL更加美观，不带有#，更接近传统的网站URL。\n缺点：后期项目上线，需要服务端配合处理路径问题，否则刷新会有404错误。\nconst router = createRouter({ history:createWebHistory(), //history模式 /******/ }) hash模式\n优点：兼容性更好，因为不需要服务器端处理路径。\n缺点：URL带有#不太美观，且在SEO优化方面相对较差。\nconst router = createRouter({ history:createWebHashHistory(), //hash模式 /******/ }) 4.5. 【to的两种写法】 # \u0026lt;!-- 第一种：to的字符串写法 --\u0026gt; \u0026lt;router-link active-class=\u0026#34;active\u0026#34; to=\u0026#34;/home\u0026#34;\u0026gt;主页\u0026lt;/router-link\u0026gt; \u0026lt;!-- 第二种：to的对象写法 --\u0026gt; \u0026lt;router-link active-class=\u0026#34;active\u0026#34; :to=\u0026#34;{path:\u0026#39;/home\u0026#39;}\u0026#34;\u0026gt;Home\u0026lt;/router-link\u0026gt; 4.6. 【命名路由】 # 作用：可以简化路由跳转及传参（后面就讲）。\n给路由规则命名：\nroutes:[ { name:\u0026#39;zhuye\u0026#39;, path:\u0026#39;/home\u0026#39;, component:Home }, { name:\u0026#39;xinwen\u0026#39;, path:\u0026#39;/news\u0026#39;, component:News, }, { name:\u0026#39;guanyu\u0026#39;, path:\u0026#39;/about\u0026#39;, component:About } ] 跳转路由：\n\u0026lt;!--简化前：需要写完整的路径（to的字符串写法） --\u0026gt; \u0026lt;router-link to=\u0026#34;/news/detail\u0026#34;\u0026gt;跳转\u0026lt;/router-link\u0026gt; \u0026lt;!--简化后：直接通过名字跳转（to的对象写法配合name属性） --\u0026gt; \u0026lt;router-link :to=\u0026#34;{name:\u0026#39;guanyu\u0026#39;}\u0026#34;\u0026gt;跳转\u0026lt;/router-link\u0026gt; 4.7. 【嵌套路由】 # 编写News的子路由：Detail.vue\n配置路由规则，使用children配置项：\nconst router = createRouter({ history:createWebHistory(), routes:[ { name:\u0026#39;zhuye\u0026#39;, path:\u0026#39;/home\u0026#39;, component:Home }, { name:\u0026#39;xinwen\u0026#39;, path:\u0026#39;/news\u0026#39;, component:News, children:[ { name:\u0026#39;xiang\u0026#39;, path:\u0026#39;detail\u0026#39;, component:Detail } ] }, { name:\u0026#39;guanyu\u0026#39;, path:\u0026#39;/about\u0026#39;, component:About } ] }) export default router 跳转路由（记得要加完整路径）：\n\u0026lt;router-link to=\u0026#34;/news/detail\u0026#34;\u0026gt;xxxx\u0026lt;/router-link\u0026gt; \u0026lt;!-- 或 --\u0026gt; \u0026lt;router-link :to=\u0026#34;{path:\u0026#39;/news/detail\u0026#39;}\u0026#34;\u0026gt;xxxx\u0026lt;/router-link\u0026gt; 记得去Home组件中预留一个\u0026lt;router-view\u0026gt;\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;news\u0026#34;\u0026gt; \u0026lt;nav class=\u0026#34;news-list\u0026#34;\u0026gt; \u0026lt;RouterLink v-for=\u0026#34;news in newsList\u0026#34; :key=\u0026#34;news.id\u0026#34; :to=\u0026#34;{path:\u0026#39;/news/detail\u0026#39;}\u0026#34;\u0026gt; {{news.name}} \u0026lt;/RouterLink\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;div class=\u0026#34;news-detail\u0026#34;\u0026gt; \u0026lt;RouterView/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 4.8. 【路由传参】 # query参数 # 传递参数\n\u0026lt;!-- 跳转并携带query参数（to的字符串写法） --\u0026gt; \u0026lt;router-link to=\u0026#34;/news/detail?a=1\u0026amp;b=2\u0026amp;content=欢迎你\u0026#34;\u0026gt; 跳转 \u0026lt;/router-link\u0026gt; \u0026lt;!-- 跳转并携带query参数（to的对象写法） --\u0026gt; \u0026lt;RouterLink :to=\u0026#34;{ //name:\u0026#39;xiang\u0026#39;, //用name也可以跳转 path:\u0026#39;/news/detail\u0026#39;, query:{ id:news.id, title:news.title, content:news.content } }\u0026#34; \u0026gt; {{news.title}} \u0026lt;/RouterLink\u0026gt; 接收参数：\nimport {useRoute} from \u0026#39;vue-router\u0026#39; const route = useRoute() // 打印query参数 console.log(route.query) params参数 # 传递参数\n\u0026lt;!-- 跳转并携带params参数（to的字符串写法） --\u0026gt; \u0026lt;RouterLink :to=\u0026#34;`/news/detail/001/新闻001/内容001`\u0026#34;\u0026gt;{{news.title}}\u0026lt;/RouterLink\u0026gt; \u0026lt;!-- 跳转并携带params参数（to的对象写法） --\u0026gt; \u0026lt;RouterLink :to=\u0026#34;{ name:\u0026#39;xiang\u0026#39;, //用name跳转 params:{ id:news.id, title:news.title, content:news.title } }\u0026#34; \u0026gt; {{news.title}} \u0026lt;/RouterLink\u0026gt; 接收参数：\nimport {useRoute} from \u0026#39;vue-router\u0026#39; const route = useRoute() // 打印params参数 console.log(route.params) 备注1：传递params参数时，若使用to的对象写法，必须使用name配置项，不能用path。\n备注2：传递params参数时，需要提前在规则中占位。\n4.9. 【路由的props配置】 # 作用：让路由组件更方便的收到参数（可以将路由参数作为props传给组件）\n{ name:\u0026#39;xiang\u0026#39;, path:\u0026#39;detail/:id/:title/:content\u0026#39;, component:Detail, // props的对象写法，作用：把对象中的每一组key-value作为props传给Detail组件 // props:{a:1,b:2,c:3}, // props的布尔值写法，作用：把收到了每一组params参数，作为props传给Detail组件 // props:true // props的函数写法，作用：把返回的对象中每一组key-value作为props传给Detail组件 props(route){ return route.query } } 4.10. 【 replace属性】 # 作用：控制路由跳转时操作浏览器历史记录的模式。\n浏览器的历史记录有两种写入方式：分别为push和replace：\npush是追加历史记录（默认值）。 replace是替换当前记录。 开启replace模式：\n\u0026lt;RouterLink replace .......\u0026gt;News\u0026lt;/RouterLink\u0026gt; 4.11. 【编程式导航】 # 路由组件的两个重要的属性：$route和$router变成了两个hooks\nimport {useRoute,useRouter} from \u0026#39;vue-router\u0026#39; const route = useRoute() const router = useRouter() console.log(route.query) console.log(route.parmas) console.log(router.push) console.log(router.replace) 4.12. 【重定向】 # 作用：将特定的路径，重新定向到已有路由。\n具体编码：\n{ path:\u0026#39;/\u0026#39;, redirect:\u0026#39;/about\u0026#39; } 5. pinia # 5.1【准备一个效果】 # 5.2【搭建 pinia 环境】 # 第一步：npm install pinia\n第二步：操作src/main.ts\nimport { createApp } from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; /* 引入createPinia，用于创建pinia */ import { createPinia } from \u0026#39;pinia\u0026#39; /* 创建pinia */ const pinia = createPinia() const app = createApp(App) /* 使用插件 */{} app.use(pinia) app.mount(\u0026#39;#app\u0026#39;) 此时开发者工具中已经有了pinia选项\n5.3【存储+读取数据】 # Store是一个保存：状态、业务逻辑 的实体，每个组件都可以读取、写入它。\n它有三个概念：state、getter、action，相当于组件中的： data、 computed 和 methods。\n具体编码：src/store/count.ts\n// 引入defineStore用于创建store import {defineStore} from \u0026#39;pinia\u0026#39; // 定义并暴露一个store export const useCountStore = defineStore(\u0026#39;count\u0026#39;,{ // 动作 actions:{}, // 状态 state(){ return { sum:6 } }, // 计算 getters:{} }) 具体编码：src/store/talk.ts\n// 引入defineStore用于创建store import {defineStore} from \u0026#39;pinia\u0026#39; // 定义并暴露一个store export const useTalkStore = defineStore(\u0026#39;talk\u0026#39;,{ // 动作 actions:{}, // 状态 state(){ return { talkList:[ {id:\u0026#39;yuysada01\u0026#39;,content:\u0026#39;你今天有点怪，哪里怪？怪好看的！\u0026#39;}, {id:\u0026#39;yuysada02\u0026#39;,content:\u0026#39;草莓、蓝莓、蔓越莓，你想我了没？\u0026#39;}, {id:\u0026#39;yuysada03\u0026#39;,content:\u0026#39;心里给你留了一块地，我的死心塌地\u0026#39;} ] } }, // 计算 getters:{} }) 组件中使用state中的数据\n\u0026lt;template\u0026gt; \u0026lt;h2\u0026gt;当前求和为：{{ sumStore.sum }}\u0026lt;/h2\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;Count\u0026#34;\u0026gt; // 引入对应的useXxxxxStore\timport {useSumStore} from \u0026#39;@/store/sum\u0026#39; // 调用useXxxxxStore得到对应的store const sumStore = useSumStore() \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;talk in talkStore.talkList\u0026#34; :key=\u0026#34;talk.id\u0026#34;\u0026gt; {{ talk.content }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;Count\u0026#34;\u0026gt; import axios from \u0026#39;axios\u0026#39; import {useTalkStore} from \u0026#39;@/store/talk\u0026#39; const talkStore = useTalkStore() \u0026lt;/script\u0026gt; 5.4.【修改数据】(三种方式) # 第一种修改方式，直接修改\ncountStore.sum = 666 第二种修改方式：批量修改\ncountStore.$patch({ sum:999, school:\u0026#39;atguigu\u0026#39; }) 第三种修改方式：借助action修改（action中可以编写一些业务逻辑）\nimport { defineStore } from \u0026#39;pinia\u0026#39; export const useCountStore = defineStore(\u0026#39;count\u0026#39;, { /*************/ actions: { //加 increment(value:number) { if (this.sum \u0026lt; 10) { //操作countStore中的sum this.sum += value } }, //减 decrement(value:number){ if(this.sum \u0026gt; 1){ this.sum -= value } } }, /*************/ }) 组件中调用action即可\n// 使用countStore const countStore = useCountStore() // 调用对应action countStore.incrementOdd(n.value) 5.5.【storeToRefs】 # 借助storeToRefs将store中的数据转为ref对象，方便在模板中使用。 注意：pinia提供的storeToRefs只会将数据做转换，而Vue的toRefs会转换store中数据。 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;count\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;当前求和为：{{sum}}\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;Count\u0026#34;\u0026gt; import { useCountStore } from \u0026#39;@/store/count\u0026#39; /* 引入storeToRefs */ import { storeToRefs } from \u0026#39;pinia\u0026#39; /* 得到countStore */ const countStore = useCountStore() /* 使用storeToRefs转换countStore，随后解构 */ const {sum} = storeToRefs(countStore) \u0026lt;/script\u0026gt; 5.6.【getters】 # 概念：当state中的数据，需要经过处理后再使用时，可以使用getters配置。\n追加getters配置。\n// 引入defineStore用于创建store import {defineStore} from \u0026#39;pinia\u0026#39; // 定义并暴露一个store export const useCountStore = defineStore(\u0026#39;count\u0026#39;,{ // 动作 actions:{ /************/ }, // 状态 state(){ return { sum:1, school:\u0026#39;atguigu\u0026#39; } }, // 计算 getters:{ bigSum:(state):number =\u0026gt; state.sum *10, upperSchool():string{ return this. school.toUpperCase() } } }) 组件中读取数据：\nconst {increment,decrement} = countStore let {sum,school,bigSum,upperSchool} = storeToRefs(countStore) 5.7.【$subscribe】 # 通过 store 的 $subscribe() 方法侦听 state 及其变化\ntalkStore.$subscribe((mutate,state)=\u0026gt;{ console.log(\u0026#39;LoveTalk\u0026#39;,mutate,state) localStorage.setItem(\u0026#39;talk\u0026#39;,JSON.stringify(talkList.value)) }) 5.8. 【store组合式写法】 # import {defineStore} from \u0026#39;pinia\u0026#39; import axios from \u0026#39;axios\u0026#39; import {nanoid} from \u0026#39;nanoid\u0026#39; import {reactive} from \u0026#39;vue\u0026#39; export const useTalkStore = defineStore(\u0026#39;talk\u0026#39;,()=\u0026gt;{ // talkList就是state const talkList = reactive( JSON.parse(localStorage.getItem(\u0026#39;talkList\u0026#39;) as string) || [] ) // getATalk函数相当于action async function getATalk(){ // 发请求，下面这行的写法是：连续解构赋值+重命名 let {data:{content:title}} = await axios.get(\u0026#39;https://api.uomg.com/api/rand.qinghua?format=json\u0026#39;) // 把请求回来的字符串，包装成一个对象 let obj = {id:nanoid(),title} // 放到数组中 talkList.unshift(obj) } return {talkList,getATalk} }) 6. 组件通信 # Vue3组件通信和Vue2的区别：\n移出事件总线，使用mitt代替。 vuex换成了pinia。 把.sync优化到了v-model里面了。 把$listeners所有的东西，合并到$attrs中了。 $children被砍掉了。 常见搭配形式：\n6.1. 【props】 # 概述：props是使用频率最高的一种通信方式，常用与 ：父 ↔ 子。\n若 父传子：属性值是非函数。 若 子传父：属性值是函数。 父组件：\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;父组件，\u0026lt;/h3\u0026gt; \u0026lt;h4\u0026gt;我的车：{{ car }}\u0026lt;/h4\u0026gt; \u0026lt;h4\u0026gt;儿子给的玩具：{{ toy }}\u0026lt;/h4\u0026gt; \u0026lt;Child :car=\u0026#34;car\u0026#34; :getToy=\u0026#34;getToy\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;Father\u0026#34;\u0026gt; import Child from \u0026#39;./Child.vue\u0026#39; import { ref } from \u0026#34;vue\u0026#34;; // 数据 const car = ref(\u0026#39;奔驰\u0026#39;) const toy = ref() // 方法 function getToy(value:string){ toy.value = value } \u0026lt;/script\u0026gt; 子组件\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;子组件\u0026lt;/h3\u0026gt; \u0026lt;h4\u0026gt;我的玩具：{{ toy }}\u0026lt;/h4\u0026gt; \u0026lt;h4\u0026gt;父给我的车：{{ car }}\u0026lt;/h4\u0026gt; \u0026lt;button @click=\u0026#34;getToy(toy)\u0026#34;\u0026gt;玩具给父亲\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;Child\u0026#34;\u0026gt; import { ref } from \u0026#34;vue\u0026#34;; const toy = ref(\u0026#39;奥特曼\u0026#39;) defineProps([\u0026#39;car\u0026#39;,\u0026#39;getToy\u0026#39;]) \u0026lt;/script\u0026gt; 6.2. 【自定义事件】 # 概述：自定义事件常用于：子 =\u0026gt; 父。 注意区分好：原生事件、自定义事件。 原生事件： 事件名是特定的（click、mosueenter等等） 事件对象$event: 是包含事件相关信息的对象（pageX、pageY、target、keyCode） 自定义事件： 事件名是任意名称 事件对象$event: 是调用emit时所提供的数据，可以是任意类型！！！ 示例：\n\u0026lt;!--在父组件中，给子组件绑定自定义事件：--\u0026gt; \u0026lt;Child @send-toy=\u0026#34;toy = $event\u0026#34;/\u0026gt; \u0026lt;!--注意区分原生事件与自定义事件中的$event--\u0026gt; \u0026lt;button @click=\u0026#34;toy = $event\u0026#34;\u0026gt;测试\u0026lt;/button\u0026gt; //子组件中，触发事件： this.$emit(\u0026#39;send-toy\u0026#39;, 具体数据) 6.3. 【mitt】 # 概述：与消息订阅与发布（pubsub）功能类似，可以实现任意组件间通信。\n安装mitt\nnpm i mitt 新建文件：src\\utils\\emitter.ts\n// 引入mitt import mitt from \u0026#34;mitt\u0026#34;; // 创建emitter const emitter = mitt() /* // 绑定事件 emitter.on(\u0026#39;abc\u0026#39;,(value)=\u0026gt;{ console.log(\u0026#39;abc事件被触发\u0026#39;,value) }) emitter.on(\u0026#39;xyz\u0026#39;,(value)=\u0026gt;{ console.log(\u0026#39;xyz事件被触发\u0026#39;,value) }) setInterval(() =\u0026gt; { // 触发事件 emitter.emit(\u0026#39;abc\u0026#39;,666) emitter.emit(\u0026#39;xyz\u0026#39;,777) }, 1000); setTimeout(() =\u0026gt; { // 清理事件 emitter.all.clear() }, 3000); */ // 创建并暴露mitt export default emitter 接收数据的组件中：绑定事件、同时在销毁前解绑事件：\nimport emitter from \u0026#34;@/utils/emitter\u0026#34;; import { onUnmounted } from \u0026#34;vue\u0026#34;; // 绑定事件 emitter.on(\u0026#39;send-toy\u0026#39;,(value)=\u0026gt;{ console.log(\u0026#39;send-toy事件被触发\u0026#39;,value) }) onUnmounted(()=\u0026gt;{ // 解绑事件 emitter.off(\u0026#39;send-toy\u0026#39;) }) 【第三步】：提供数据的组件，在合适的时候触发事件\nimport emitter from \u0026#34;@/utils/emitter\u0026#34;; function sendToy(){ // 触发事件 emitter.emit(\u0026#39;send-toy\u0026#39;,toy.value) } 注意这个重要的内置关系，总线依赖着这个内置关系\n6.4.【v-model】 # 概述：实现 父↔子 之间相互通信。\n前序知识 —— v-model的本质\n\u0026lt;!-- 使用v-model指令 --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;userName\u0026#34;\u0026gt; \u0026lt;!-- v-model的本质是下面这行代码 --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; :value=\u0026#34;userName\u0026#34; @input=\u0026#34;userName =(\u0026lt;HTMLInputElement\u0026gt;$event.target).value\u0026#34; \u0026gt; 组件标签上的v-model的本质：:moldeValue ＋ update:modelValue事件。\n\u0026lt;!-- 组件标签上使用v-model指令 --\u0026gt; \u0026lt;AtguiguInput v-model=\u0026#34;userName\u0026#34;/\u0026gt; \u0026lt;!-- 组件标签上v-model的本质 --\u0026gt; \u0026lt;AtguiguInput :modelValue=\u0026#34;userName\u0026#34; @update:model-value=\u0026#34;userName = $event\u0026#34;/\u0026gt; AtguiguInput组件中：\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;!--将接收的value值赋给input元素的value属性，目的是：为了呈现数据 --\u0026gt; \u0026lt;!--给input元素绑定原生input事件，触发input事件时，进而触发update:model-value事件--\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; :value=\u0026#34;modelValue\u0026#34; @input=\u0026#34;emit(\u0026#39;update:model-value\u0026#39;,$event.target.value)\u0026#34; \u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;AtguiguInput\u0026#34;\u0026gt; // 接收props defineProps([\u0026#39;modelValue\u0026#39;]) // 声明事件 const emit = defineEmits([\u0026#39;update:model-value\u0026#39;]) \u0026lt;/script\u0026gt; 也可以更换value，例如改成abc\n\u0026lt;!-- 也可以更换value，例如改成abc--\u0026gt; \u0026lt;AtguiguInput v-model:abc=\u0026#34;userName\u0026#34;/\u0026gt; \u0026lt;!-- 上面代码的本质如下 --\u0026gt; \u0026lt;AtguiguInput :abc=\u0026#34;userName\u0026#34; @update:abc=\u0026#34;userName = $event\u0026#34;/\u0026gt; AtguiguInput组件中：\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; :value=\u0026#34;abc\u0026#34; @input=\u0026#34;emit(\u0026#39;update:abc\u0026#39;,$event.target.value)\u0026#34; \u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;AtguiguInput\u0026#34;\u0026gt; // 接收props defineProps([\u0026#39;abc\u0026#39;]) // 声明事件 const emit = defineEmits([\u0026#39;update:abc\u0026#39;]) \u0026lt;/script\u0026gt; 如果value可以更换，那么就可以在组件标签上多次使用v-model\n\u0026lt;AtguiguInput v-model:abc=\u0026#34;userName\u0026#34; v-model:xyz=\u0026#34;password\u0026#34;/\u0026gt; 6.5.【$attrs 】 # 概述：$attrs用于实现当前组件的父组件，向当前组件的子组件通信（祖→孙）。\n具体说明：$attrs是一个对象，包含所有父组件传入的标签属性。\n注意：$attrs会自动排除props中声明的属性(可以认为声明过的 props 被子组件自己“消费”了)\n父组件：\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;父组件\u0026lt;/h3\u0026gt; \u0026lt;Child :a=\u0026#34;a\u0026#34; :b=\u0026#34;b\u0026#34; :c=\u0026#34;c\u0026#34; :d=\u0026#34;d\u0026#34; v-bind=\u0026#34;{x:100,y:200}\u0026#34; :updateA=\u0026#34;updateA\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;Father\u0026#34;\u0026gt; import Child from \u0026#39;./Child.vue\u0026#39; import { ref } from \u0026#34;vue\u0026#34;; let a = ref(1) let b = ref(2) let c = ref(3) let d = ref(4) function updateA(value){ a.value = value } \u0026lt;/script\u0026gt; 子组件：\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;子组件\u0026lt;/h3\u0026gt; \u0026lt;GrandChild v-bind=\u0026#34;$attrs\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;Child\u0026#34;\u0026gt; import GrandChild from \u0026#39;./GrandChild.vue\u0026#39; \u0026lt;/script\u0026gt; 孙组件：\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;grand-child\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;孙组件\u0026lt;/h3\u0026gt; \u0026lt;h4\u0026gt;a：{{ a }}\u0026lt;/h4\u0026gt; \u0026lt;h4\u0026gt;b：{{ b }}\u0026lt;/h4\u0026gt; \u0026lt;h4\u0026gt;c：{{ c }}\u0026lt;/h4\u0026gt; \u0026lt;h4\u0026gt;d：{{ d }}\u0026lt;/h4\u0026gt; \u0026lt;h4\u0026gt;x：{{ x }}\u0026lt;/h4\u0026gt; \u0026lt;h4\u0026gt;y：{{ y }}\u0026lt;/h4\u0026gt; \u0026lt;button @click=\u0026#34;updateA(666)\u0026#34;\u0026gt;点我更新A\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;GrandChild\u0026#34;\u0026gt; defineProps([\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;x\u0026#39;,\u0026#39;y\u0026#39;,\u0026#39;updateA\u0026#39;]) \u0026lt;/script\u0026gt; 6.6. 【$refs、$parent】 # 概述：\n$refs用于 ：父→子。 $parent用于：子→父。 原理如下：\n属性 说明 $refs 值为对象，包含所有被ref属性标识的DOM元素或组件实例。 $parent 值为对象，当前组件的父组件实例对象。 6.7. 【provide、inject】 # 概述：实现祖孙组件直接通信\n具体使用：\n在祖先组件中通过provide配置向后代组件提供数据 在后代组件中通过inject配置来声明接收数据 具体编码：\n【第一步】父组件中，使用provide提供数据\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;父组件\u0026lt;/h3\u0026gt; \u0026lt;h4\u0026gt;资产：{{ money }}\u0026lt;/h4\u0026gt; \u0026lt;h4\u0026gt;汽车：{{ car }}\u0026lt;/h4\u0026gt; \u0026lt;button @click=\u0026#34;money += 1\u0026#34;\u0026gt;资产+1\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;car.price += 1\u0026#34;\u0026gt;汽车价格+1\u0026lt;/button\u0026gt; \u0026lt;Child/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;Father\u0026#34;\u0026gt; import Child from \u0026#39;./Child.vue\u0026#39; import { ref,reactive,provide } from \u0026#34;vue\u0026#34;; // 数据 let money = ref(100) let car = reactive({ brand:\u0026#39;奔驰\u0026#39;, price:100 }) // 用于更新money的方法 function updateMoney(value:number){ money.value += value } // 提供数据 provide(\u0026#39;moneyContext\u0026#39;,{money,updateMoney}) provide(\u0026#39;car\u0026#39;,car) \u0026lt;/script\u0026gt; 注意：子组件中不用编写任何东西，是不受到任何打扰的\n【第二步】孙组件中使用inject配置项接受数据。\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;grand-child\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;我是孙组件\u0026lt;/h3\u0026gt; \u0026lt;h4\u0026gt;资产：{{ money }}\u0026lt;/h4\u0026gt; \u0026lt;h4\u0026gt;汽车：{{ car }}\u0026lt;/h4\u0026gt; \u0026lt;button @click=\u0026#34;updateMoney(6)\u0026#34;\u0026gt;点我\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;GrandChild\u0026#34;\u0026gt; import { inject } from \u0026#39;vue\u0026#39;; // 注入数据 let {money,updateMoney} = inject(\u0026#39;moneyContext\u0026#39;,{money:0,updateMoney:(x:number)=\u0026gt;{}}) let car = inject(\u0026#39;car\u0026#39;) ## 6.8. 【pinia】\r参考之前`pinia`部分的讲解\r## 6.9. 【slot】\r### 1. 默认插槽\r![img](http://49.232.112.44/images/default_slot.png)\r```vue\r父组件中：\r\u0026lt;Category title=\u0026#34;今日热门游戏\u0026#34;\u0026gt;\r\u0026lt;ul\u0026gt;\r\u0026lt;li v-for=\u0026#34;g in games\u0026#34; :key=\u0026#34;g.id\u0026#34;\u0026gt;{{ g.name }}\u0026lt;/li\u0026gt;\r\u0026lt;/ul\u0026gt;\r\u0026lt;/Category\u0026gt;\r子组件中：\r\u0026lt;template\u0026gt;\r\u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\r\u0026lt;h3\u0026gt;{{ title }}\u0026lt;/h3\u0026gt;\r\u0026lt;!-- 默认插槽 --\u0026gt;\r\u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt;\r\u0026lt;/div\u0026gt;\r\u0026lt;/template\u0026gt; 2. 具名插槽 # 父组件中： \u0026lt;Category title=\u0026#34;今日热门游戏\u0026#34;\u0026gt; \u0026lt;template v-slot:s1\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;g in games\u0026#34; :key=\u0026#34;g.id\u0026#34;\u0026gt;{{ g.name }}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template #s2\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;更多\u0026lt;/a\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Category\u0026gt; 子组件中： \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;{{ title }}\u0026lt;/h3\u0026gt; \u0026lt;slot name=\u0026#34;s1\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;slot name=\u0026#34;s2\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 3. 作用域插槽 # 理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。（新闻数据在News组件中，但使用数据所遍历出来的结构由App组件决定）\n具体编码：\n父组件中： \u0026lt;Game v-slot=\u0026#34;params\u0026#34;\u0026gt; \u0026lt;!-- \u0026lt;Game v-slot:default=\u0026#34;params\u0026#34;\u0026gt; --\u0026gt; \u0026lt;!-- \u0026lt;Game #default=\u0026#34;params\u0026#34;\u0026gt; --\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;g in params.games\u0026#34; :key=\u0026#34;g.id\u0026#34;\u0026gt;{{ g.name }}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/Game\u0026gt; 子组件中： \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;category\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;今日游戏榜单\u0026lt;/h2\u0026gt; \u0026lt;slot :games=\u0026#34;games\u0026#34; a=\u0026#34;哈哈\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34; name=\u0026#34;Category\u0026#34;\u0026gt; import {reactive} from \u0026#39;vue\u0026#39; let games = reactive([ {id:\u0026#39;asgdytsa01\u0026#39;,name:\u0026#39;英雄联盟\u0026#39;}, {id:\u0026#39;asgdytsa02\u0026#39;,name:\u0026#39;王者荣耀\u0026#39;}, {id:\u0026#39;asgdytsa03\u0026#39;,name:\u0026#39;红色警戒\u0026#39;}, {id:\u0026#39;asgdytsa04\u0026#39;,name:\u0026#39;斗罗大陆\u0026#39;} ]) \u0026lt;/script\u0026gt; 7. 其它 API # 7.1.【shallowRef 与 shallowReactive 】 # shallowRef # 作用：创建一个响应式数据，但只对顶层属性进行响应式处理。\n用法：\nlet myVar = shallowRef(initialValue); 特点：只跟踪引用值的变化，不关心值内部的属性变化。\nshallowReactive # 作用：创建一个浅层响应式对象，只会使对象的最顶层属性变成响应式的，对象内部的嵌套属性则不会变成响应式的\n用法：\nconst myObj = shallowReactive({ ... }); 特点：对象的顶层属性是响应式的，但嵌套对象的属性不是。\n总结 # 通过使用 shallowRef() 和 shallowReactive() 来绕开深度响应。浅层式 API 创建的状态只在其顶层是响应式的，对所有深层的对象不会做任何处理，避免了对每一个内部属性做响应式所带来的性能成本，这使得属性的访问变得更快，可提升性能。\n7.2.【readonly 与 shallowReadonly】 # readonly # 作用：用于创建一个对象的深只读副本。\n用法：\nconst original = reactive({ ... }); const readOnlyCopy = readonly(original); 特点：\n对象的所有嵌套属性都将变为只读。 任何尝试修改这个对象的操作都会被阻止（在开发模式下，还会在控制台中发出警告）。 应用场景：\n创建不可变的状态快照。 保护全局状态或配置不被修改。 shallowReadonly # 作用：与 readonly 类似，但只作用于对象的顶层属性。\n用法：\nconst original = reactive({ ... }); const shallowReadOnlyCopy = shallowReadonly(original); 特点：\n只将对象的顶层属性设置为只读，对象内部的嵌套属性仍然是可变的。\n适用于只需保护对象顶层属性的场景。\n7.3.【toRaw 与 markRaw】 # toRaw # 作用：用于获取一个响应式对象的原始对象， toRaw 返回的对象不再是响应式的，不会触发视图更新。\n官网描述：这是一个可以用于临时读取而不引起代理访问/跟踪开销，或是写入而不触发更改的特殊方法。不建议保存对原始对象的持久引用，请谨慎使用。\n何时使用？ —— 在需要将响应式对象传递给非 Vue 的库或外部系统时，使用 toRaw 可以确保它们收到的是普通对象\n具体编码：\nimport { reactive,toRaw,markRaw,isReactive } from \u0026#34;vue\u0026#34;; /* toRaw */ // 响应式对象 let person = reactive({name:\u0026#39;tony\u0026#39;,age:18}) // 原始对象 let rawPerson = toRaw(person) /* markRaw */ let citysd = markRaw([ {id:\u0026#39;asdda01\u0026#39;,name:\u0026#39;北京\u0026#39;}, {id:\u0026#39;asdda02\u0026#39;,name:\u0026#39;上海\u0026#39;}, {id:\u0026#39;asdda03\u0026#39;,name:\u0026#39;天津\u0026#39;}, {id:\u0026#39;asdda04\u0026#39;,name:\u0026#39;重庆\u0026#39;} ]) // 根据原始对象citys去创建响应式对象citys2 —— 创建失败，因为citys被markRaw标记了 let citys2 = reactive(citys) console.log(isReactive(person)) console.log(isReactive(rawPerson)) console.log(isReactive(citys)) console.log(isReactive(citys2)) markRaw # 作用：标记一个对象，使其永远不会变成响应式的。\n例如使用mockjs时，为了防止误把mockjs变为响应式对象，可以使用 markRaw 去标记mockjs\n编码：\n/* markRaw */ let citys = markRaw([ {id:\u0026#39;asdda01\u0026#39;,name:\u0026#39;北京\u0026#39;}, {id:\u0026#39;asdda02\u0026#39;,name:\u0026#39;上海\u0026#39;}, {id:\u0026#39;asdda03\u0026#39;,name:\u0026#39;天津\u0026#39;}, {id:\u0026#39;asdda04\u0026#39;,name:\u0026#39;重庆\u0026#39;} ]) // 根据原始对象citys去创建响应式对象citys2 —— 创建失败，因为citys被markRaw标记了 let citys2 = reactive(citys) 7.4.【customRef】 # 作用：创建一个自定义的ref，并对其依赖项跟踪和更新触发进行逻辑控制。\n实现防抖效果（useSumRef.ts）：\nimport {customRef } from \u0026#34;vue\u0026#34;; export default function(initValue:string,delay:number){ let msg = customRef((track,trigger)=\u0026gt;{ let timer:number return { get(){ track() // 告诉Vue数据msg很重要，要对msg持续关注，一旦变化就更新 return initValue }, set(value){ clearTimeout(timer) timer = setTimeout(() =\u0026gt; { initValue = value trigger() //通知Vue数据msg变化了 }, delay); } } }) return {msg} } 组件中使用：\n8. Vue3新组件 # 8.1. 【Teleport】 # 什么是Teleport？—— Teleport 是一种能够将我们的组件html结构移动到指定位置的技术。 \u0026lt;teleport to=\u0026#39;body\u0026#39; \u0026gt; \u0026lt;div class=\u0026#34;modal\u0026#34; v-show=\u0026#34;isShow\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;我是一个弹窗\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;我是弹窗中的一些内容\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026#34;isShow = false\u0026#34;\u0026gt;关闭弹窗\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/teleport\u0026gt; 8.2. 【Suspense】 # 等待异步组件时渲染一些额外内容，让应用有更好的用户体验 使用步骤： 异步引入组件 使用Suspense包裹组件，并配置好default 与 fallback import { defineAsyncComponent,Suspense } from \u0026#34;vue\u0026#34;; const Child = defineAsyncComponent(()=\u0026gt;import(\u0026#39;./Child.vue\u0026#39;)) \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;我是App组件\u0026lt;/h3\u0026gt; \u0026lt;Suspense\u0026gt; \u0026lt;template v-slot:default\u0026gt; \u0026lt;Child/\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template v-slot:fallback\u0026gt; \u0026lt;h3\u0026gt;加载中.......\u0026lt;/h3\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Suspense\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 8.3.【全局API转移到应用对象】 # app.component app.config app.directive app.mount app.unmount app.use 8.4.【其他】 # 过渡类名 v-enter 修改为 v-enter-from、过渡类名 v-leave 修改为 v-leave-from。\nkeyCode 作为 v-on 修饰符的支持。\nv-model 指令在组件上的使用已经被重新设计，替换掉了 v-bind.sync。\nv-if 和 v-for 在同一个元素身上使用时的优先级发生了变化。\n移除了$on、$off 和 $once 实例方法。\n移除了过滤器 filter。\n移除了$children 实例 propert。\n\u0026hellip;\u0026hellip;\n","externalUrl":null,"permalink":"/posts/vue/vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/","section":"Posts","summary":"","title":"","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]